static Item** find_field_in_group_list(Item *find_item, ORDER *group_list)
{
  const char *db_name;
  const char *table_name;
  const char *field_name;
  ORDER      *found_group= NULL;
  int         found_match_degree= 0;
  char        name_buff[SAFE_NAME_LEN+1];

  if (find_item->type() == Item::FIELD_ITEM ||
      find_item->type() == Item::REF_ITEM)
  {
    db_name=    ((Item_ident*) find_item)->db_name;
    table_name= ((Item_ident*) find_item)->table_name;
    field_name= ((Item_ident*) find_item)->field_name;
  }
  else
    return NULL;

  if (db_name && lower_case_table_names)
  {
    /* Convert database to lower case for comparison */
    strmake_buf(name_buff, db_name);
    my_casedn_str(files_charset_info, name_buff);
    db_name= name_buff;
  }

  DBUG_ASSERT(field_name != 0);

  for (ORDER *cur_group= group_list ; cur_group ; cur_group= cur_group->next)
  {
    int cur_match_degree= 0;

    /* SELECT list element with explicit alias */
    if ((*(cur_group->item))->name && !table_name &&
        !(*(cur_group->item))->is_autogenerated_name &&
        !my_strcasecmp(system_charset_info,
                       (*(cur_group->item))->name, field_name))
    {
      ++cur_match_degree;
    }
    /* Reference on the field or view/derived field. */
    else if ((*(cur_group->item))->type() == Item::FIELD_ITEM ||
             (*(cur_group->item))->type() == Item::REF_ITEM )
    {
      Item_ident *cur_field= (Item_ident*) *cur_group->item;
      const char *l_db_name= cur_field->db_name;
      const char *l_table_name= cur_field->table_name;
      const char *l_field_name= cur_field->field_name;

      DBUG_ASSERT(l_field_name != 0);

      if (!my_strcasecmp(system_charset_info,
                         l_field_name, field_name))
        ++cur_match_degree;
      else
        continue;

      if (l_table_name && table_name)
      {
        /* If field_name is qualified by a table name. */
        if (my_strcasecmp(table_alias_charset, l_table_name, table_name))
          /* Same field names, different tables. */
          return NULL;

        ++cur_match_degree;
        if (l_db_name && db_name)
        {
          /* If field_name is also qualified by a database name. */
          if (strcmp(l_db_name, db_name))
            /* Same field names, different databases. */
            return NULL;
          ++cur_match_degree;
        }
      }
    }
    else
      continue;

    if (cur_match_degree > found_match_degree)
    {
      found_match_degree= cur_match_degree;
      found_group= cur_group;
    }
    else if (found_group && (cur_match_degree == found_match_degree) &&
             !(*(found_group->item))->eq((*(cur_group->item)), 0))
    {
      /*
        If the current resolve candidate matches equally well as the current
        best match, they must reference the same column, otherwise the field
        is ambiguous.
      */
      my_error(ER_NON_UNIQ_ERROR, MYF(0),
               find_item->full_name(), current_thd->where);
      return NULL;
    }
  }

  if (found_group)
    return found_group->item;
  else
    return NULL;
}